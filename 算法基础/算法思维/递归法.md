# 递归法 Recursion method

递归，在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。简单来说，递归表现为函数调用函数本身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。

> 递归最恰当的比喻，就是查词典。我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。

递归算法思想往往用函数的形式来体现，所以递归算法需要预先编写功能函数。这些函数是独立的功能，能够实现解决某个问题的具体功能，当需要时直接调用这个函数即可。在计算机编程应用中，递归算法对解决大多数问题是十分有效的，它能够使算法的描述变得简洁而且易于理解。递归算法有如下 3 个特点。

- 递归过程一般通过函数或子过程来实现。
- 递归算法在函数或子过程的内部，直接或者间接地调用自己的算法。
- 递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解。

递归代码最重要的两个特征：结束条件和自我调用，

- 自身调用：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，即都是调用自身的同一个函数。
- 终止条件：递归必须有一个终止的条件，即不能无限循环地调用本身。

```go
public int sum(int n) {
    if (n <= 1) {
        return 1;
    }
    return sum(n - 1) + n;
}
```

总结而言，在使用递归算法时，应该注意如下几点。

- 递归是在过程或函数中调用自身的过程。
- 在使用递归策略时，必须有一个明确的递归结束条件，这称为递归出口。
- 递归算法通常显得很简洁，但是运行效率较低，所以一般不提倡用递归算法设计程序。
- 在递归调用过程中，系统用栈来存储每一层的返回点和局部量。如果递归次数过多，则容易造成栈溢出，所以一般不提倡用递归算法设计程序。

# 递归解题思路

# 案例：二叉树路径求和

给一课二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数，让你编写 pathSum 函数：

```s
/* 来源于 LeetCode PathSum III： https://leetcode.com/problems/path-sum-iii/ */
root = [10,5,-3,3,2,null,11,3,-2,null,1],
sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架（分别对左右孩子递归调用函数本身）必然要出现在主函数 pathSum 中：

- pathSum 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，和为目标值的路径总数。
- count 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。

```c
int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    return count(root, sum) +
        pathSum(root.left, sum) + pathSum(root.right, sum);
}

int count(TreeNode node, int sum) {
    if (node == null) return 0;
    return (node.val == sum) +
        count(node.left, sum - node.val) + count(node.right, sum - node.val);
}
```
