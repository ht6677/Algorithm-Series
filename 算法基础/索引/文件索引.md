# 文件索引

文件索引允许我们能够以较快地速度查询到目标文件的存储地址，其最典型的应用场景即是 MySQL 等关系型数据库。在数据库中,数据本身是存储在文件里的，而为了能够快速定位到某张表里的某条记录进行查询和修改，我们需要将这些数据以一定的数据结构进行存储，这个数据结构就是我们说的索引。

实际应用中，我们往往使用 B+ 树或者 LSM 来替代二叉查找树或者红黑树来构建索引系统，并且充分利用[虚拟存储管理](https://ng-tech.icu/DistributedSystem-Series/#/) 一节中介绍过的局部性原理、磁盘预读与页缓存等概念。

# 索引基础

在常用的数据结构中，能够支持快速查找的数据结构有顺序数组、哈希、搜索树等，本段就是讨论下几种基础的查找数据结构的优劣。

![](https://i.postimg.cc/BvC1DWBz/image.png)

## 数组

数组要求插入的时候保证有序，这样查找的时候可以利用二分查找法达到 `O(log(N))` 的时间复杂度，对范围查询支持也很好，但是插入的时候如果不是在数组尾部，就需要摞动后面所有的数据，时间复杂度为 `O(N)`。所以有序数组只适合存储静态数据，例如几乎很少变动的配置数据，或者是历史数据。这里应该会有人有疑问：我用另外一种线性数据结构链表来替代数组不就可以解决数组插入因为要移动数据导致太慢的问题了么，要回答这个问题我们需要了解操作系统读取文件的流程，磁盘 IO 是一个相对很慢的操作，为了提高读取速度，我们应该尽量减少磁盘 IO 操作，而操作系统一般以 4KB 为一个数据页读取数据，而 MySQL 一般为 16kb 作为一个数据块，已经读取的数据块会在内存进行缓存，如果多次数据读取在同一个数据块，则只需要一次磁盘 IO，而如果顺序一致的记录在文件中也是顺序存储的，就可以一次读取多个数据块，这样范围查询的速度也可以大大提升，显然链表没有这方面的优势。

## 二叉树

典型的索引譬如在内存中维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在 `O(log2n)` 的复杂度内获取到相应数据。

![](https://ww1.sinaimg.cn/large/007rAy9hgy1g10cogz8p1j30gc089dge.jpg)

左侧为数据记录的物理地址，右侧为查找树，需要注意的是，逻辑上相邻的记录在磁盘上也并不是一定物理相邻的。

二叉树在极端情况下会变成线性结构，也就是每个节点都只有左子节点或者只有右子节点，这样就无法利用二分查找只能从第一个节点开始向后遍历了，所以为了维持　 O(log(N))　的时间复杂度，我们需要在插入节点的时候对节点进行调整以保证树的平衡，所以平衡二叉树插入的时间复杂度也是　 O(log(N))　，二叉树只有两个子节点，如果数据量很大则树就很高，树的每一层一般不在同一个数据块中存储，为了尽量的减少磁盘读写次数，我们用Ｎ叉树来代替二叉树，在 MySQL 中这个Ｎ一般为　 1200 ，这样树高是　４　的话也可以存储亿级别的数据，而且树的前面两层一般都在内存中， MySQL 中用到的　Ｂ＋　树，一般用非叶子节点构建索引，而叶子节点用来存储具体的值。

## 哈希索引

[![image.png](https://i.postimg.cc/zvwK1jyc/image.png)](https://postimg.cc/H8xVwb4w)

哈希索引即是基于哈希技术，如上图所示，我们将一系列的最终的键值通过哈希函数转化为存储实际数据桶的地址数值。值本身存储的地址就是基于哈希函数的计算结果，而搜索的过程就是利用哈希函数从元数据中推导出桶的地址。

- 添加新值的流程，首先会根据哈希函数计算出存储数据的地址，如果该地址已经被占用，则添加新桶并重新计算哈希函数。
- 更新值的流程则是先搜索到目标值的地址，然后对该内存地址应用所需的操作。

哈希索引的实现思路是，对一个字符串字段，为其每个值都计算一个哈希值，并且建立一个新字段用于存储这些哈希值，然后为这个新字段建立索引，并且为字符串字段建立插入和更新的触发器，用于更新哈希字段的值。在进行查询时，使用同一哈希算法计算查询的字符串的哈希值，使用该哈希值在哈希字段上进行查询，由于建立了索引，因而查询非常快，对于查询到的结果将查询的字符串与查询结果的字符串字段进行比较，从而得到最后的结果。这里由于新建立的哈希字段是整型的，因而其索引片非常小，并且由于字符串字段的选择性非常高，因而哈希字段的选择性相对非常高，因而总体而言，查询效率是非常高的。

哈希索引会在进行相等性测试（等或者不等）时候具有非常高的性能，但是在进行比较查询、Order By 等更为复杂的场景下就无能为力。

- 哈希索引仅仅能满足=，<=>，IN，IS NULL 或者 IS NOT NULL 查询，不能使用范围查询。由于哈希索引比较的是进行哈希运算之后的哈希值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的哈希算法处理之后的哈希值的大小关系，并不能保证和哈希运算前完全一样。

- 哈希索引无法被用来避免数据的排序操作。由于哈希索引中存放的是经过哈希计算之后的哈希值，而且哈希值的大小关系并不一定和哈希运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

- 哈希索引不能利用部分索引键查询。对于组合索引，哈希索引在计算哈希值的时候是组合索引键合并后再一起计算哈希值，而不是单独计算哈希值，所以通过组合索引的前面一个或几个索引键进行查询的时候，哈希索引也无法被利用。

- 哈希索引在任何时候都不能避免表扫描。前面已经知道，哈希索引是将索引键通过哈希运算之后，将哈希运算结果的哈希值和所对应的行指针信息存放于一个哈希表中，由于不同索引键存在相同哈希值，所以即使取满足某个哈希键值的数据的记录条数，也无法从 哈希索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

- 哈希索引遇到大量哈希值相等的情况后性能并不一定就会比 B-Tree 索引高。对于选择性比较低的索引键，如果创建哈希索引，那么将会存在大量记录指针信息存于同一个哈希值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

# B-Tree

在[数据结构与算法/查找树 https://url.wx-coder.cn/9PnzG](https://url.wx-coder.cn/9PnzG) 一节中我们介绍了 B-Tree 的基本概念与实现，这里我们继续来分析下为何 B-Tree 相较于红黑树等二叉查找树会更适合于作为数据库索引的实现。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 IO 消耗，相对于内存存取，IO 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 IO 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 IO 的存取次数。

![](https://tva1.sinaimg.cn/large/007rAy9hgy1g3fw872x3gj30ou08aab4.jpg)

根据 B-Tree 的定义，可知检索一次最多需要访问 h 个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 IO 就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次 IO。而检索的时候，一次检索最多需要 h-1 次 IO（根节点常驻内存），其渐进复杂度为 $O(h)=O(log_dN)O(h)=O(log_dN)$，实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 IO 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。

# B+Tree

B+Tree 是 B-Tree 的变种，有着比 B-Tree 更高的查询性能，其相较于 B-Tree 有了如下的变化：

- 有 m 个子树的节点包含有 m 个元素（B-Tree 中是 m-1）。

- 根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。

- 所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。

- 叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。

一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 的基础上进行了优化，增加了顺序访问指针：

![](https://i.postimg.cc/7Z0zHJGw/image.png)

如上图所示，在 B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree。做这个优化的目的是为了提高区间访问的性能，例如下图中如果要查询 key 为从 3 到 8 的所有数据记录，当找到 3 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

![](https://i.postimg.cc/j5Z7j5xs/image.png)

# LSM-Tree

B-Tree 这种数据库索引方式是传统关系型数据库中主要的索引构建方式，然而 B-Tree 通常会存在写操作吞吐量上的瓶颈，其需要大量的磁盘随机 IO，很显然，大量的磁盘随机 IO 会严重影响索引建立的速度。对于那些索引数据大的情况(例如，两个列的联合索引)，插入速度是对性能影响的重要指标，而读取相对来说就比较少。譬如在一个无缓存的情况下，B-Tree 首先需要进行一次磁盘读写将磁盘页读取到内存中，然后进行修改，最后再进行一次 IO 写回到磁盘中。

LSM-Tree 则采取读写分离的策略，会优先保证写操作的性能；其数据首先存储内存中，而后需要定期 Flush 到硬盘上。LSM-Tree 通过内存插入与磁盘的顺序写，来达到最优的写性能，因为这会大大降低磁盘的寻道次数，一次磁盘 IO 可以写入多个索引块。HBase, Cassandra, RockDB, LevelDB, SQLite 等都是基于 LSM-Tree 来构建索引的数据库；LSM-Tree 的树节点可以分为两种，保存在内存中的称之为 MemTable, 保存在磁盘上的称之为 SSTable。

![image](https://i.postimg.cc/CMn80FyV/51817950-f691bc00-2307-11e9-9492-b819d7a61ec0.png)

LSM-Tree 的主要思想是划分不同等级的树。以两级树为例，可以想象一份索引数据由两个树组成，一棵树存在于内存，一棵树存在于磁盘。内存中的树可以可以是 AVL Tree 等结构；因为数据大小是不同的，没必要牺牲 CPU 来达到最小的树高度。而存在于磁盘的树是一棵 B-Tree。

![](http://dl.iteye.com/upload/picture/pic/118173/9092b78b-5c7a-37df-b9f2-fb8038bb79b9.jpg)

数据首先会插入到内存中的树。当内存中的树中的数据超过一定阈值时，会进行合并操作。合并操作会从左至右遍历内存中的树的叶子节点与磁盘中的树的叶子节点进行合并，当被合并的数据量达到磁盘的存储页的大小时，会将合并后的数据持久化到磁盘，同时更新父亲节点对叶子节点的指针。

![](http://dl.iteye.com/upload/picture/pic/118175/7ece3749-415a-3083-893e-6859c9b9fc78.jpg)

之前存在于磁盘的叶子节点被合并后，旧的数据并不会被删除，这些数据会拷贝一份和内存中的数据一起顺序写到磁盘。这会操作一些空间的浪费，但是，LSM-Tree 提供了一些机制来回收这些空间。磁盘中的树的非叶子节点数据也被缓存在内存中。数据查找会首先查找内存中树，如果没有查到结果，会转而查找磁盘中的树。有一个很显然的问题是，如果数据量过于庞大，磁盘中的树相应地也会很大，导致的后果是合并的速度会变慢。一个解决方法是建立各个层次的树，低层次的树都比 上一层次的树数据集大。假设内存中的树为 c0, 磁盘中的树按照层次一次为 `c1, c2, c3, ... ck-1, ck`，合并的顺序是 `(c0, c1), (c1, c2)...(ck-1, ck)`。
