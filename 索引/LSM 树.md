# LSM-Tree

我们需要一整套的机制来完成从内存排序、写入到磁盘、压缩以及快速读取，这样的完整机制和架构称为 LSM-Tree(The Log-Structured Merge-Tree)。名字很形象，首先是基于 log 的，不断产生 SSTable 结构的 log 文件，并且是需要不断 merge 以提高效率。基于合并和压缩排序文件原理的存储引擎通常都被成为 LSM 存储引擎。

LSM-Tree 的基本思想足够简单有效，可以有效地支持区间查询，支持非常高的写入吞吐量。但当 LSM-Tree 查找某个数据库中不存在的 key 时，需要检查索引及所有的段文件，为了优化这种情况，存储引擎通常会使用布隆过滤器。

# 哈希表

在数据库实现中，首先考虑建立最简单的 key-value 索引，通常采用类似 HashMap 的方式来实现。如果所有的存储采用追加文件的方式完成，那么可以在内存中保存这个 HashMap，其中 Map 的值对应文件中的偏移量。当写入和更新时需要同时更新索引，查询时首先找到 Map 中的偏移量然后读取文件中的内容。为了避免过多的磁盘占用，我们可以将文件分为不同的段，每个段对应一个哈希索引表，新写入的数据追加在最新的段上，每过一段时间后台合并压缩多个段。为了找到 key 对应的 value，首先检查最新段的 HashMap，如果不存在则依次检查次新的段，以此类推。

# SSTables

如果简单地改变段文件的格式，要求 key-value 的顺序按照 key 排序，那么这就变成了排序字符串表（SSTable），它要求每个键在每个合并的段文件中只能出现一次。这样相比不排序的哈希索引日志段模式，具有以下优点：

- 合并段更加高效，即是每个段非常大，也能利用类似归并排序中的合并算法，支持同时合并多个段。
- 查找特定 key 时，无需在内存索引中保留所有的 key。如要查找 AAD 则只需要知道 AA 和 AAM 的偏移量。同时也支持了区间查询。
- 可以压缩文件，将索引的每个 key 对应压缩块的开头

维护排序的结构在内存中更容易（如红黑树），利用这些数据结构，我们的存储引擎可以这样工作：数据写入时将其加到内存中的平衡树中，当树太大时，将其作为 SSTable 文件写入磁盘，同时后台可以对多个 SSTable 进行合并压缩。查询时先在内存数查找 key，再查找最新的文件段、次新文件段，以此类推。LevelDB、RocksDB、Tair LDB、HBase、Lucene 正是基于以上基本算法。
